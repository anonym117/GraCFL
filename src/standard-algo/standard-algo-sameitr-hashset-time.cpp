#include "globals.hpp"
#include "grammar.hpp"

/***
 * This is the standard algorithm for CFL Reachability analysis
 */

int main(int argc, char **argv)
{

	// bool debug = true;
	if (argc == 1)
	{
		cout << "Please provide the graph file path and grammar file path. For example, ./topo-driven <graph_file> <grammar_file>" << endl;
		return 0;
	}
	else if (argc == 2)
	{
		cout << "Please provide the grammar file path. For example, ./topo-driven <graph_file> <grammar_file>" << endl;
		return 0;
	}

	const string inputGraph = argv[1];
	Grammar grammar(argv[2]);

	uint num_nodes = 0;
	uint num_edges = 0;

	ifstream infile(inputGraph);

	vector<EdgeForReading2> edges;
	unordered_set<uint> nodes;
	EdgeForReading2 newEdge;
	uint from, to;
	string label;
	while (infile >> newEdge.from)
	{
		infile >> newEdge.to;
		infile >> label;
		// if the label does not exist in the Grammar, discard
		if (grammar.hashSym.find(label) == grammar.hashSym.end())
		{
			continue;
		}
		newEdge.label = grammar.hashSym[label];

		edges.push_back(newEdge);

		num_edges++;
		num_nodes = max(num_nodes, max(newEdge.from + 1, newEdge.to + 1));
		// If we insert the nodes into the set, the duplicate nodes will automatically get
		// discarded by the set.
		nodes.insert(newEdge.from);
		nodes.insert(newEdge.to);
	}

	infile.close();

	vector<uint> **inEdgeVecs = new vector<uint> *[grammar.labelSize];
	// level-1: vertex ID, level-2: NEW, OLD, FUTURE, level-3: outgoing edges
	// topo-driven only needs outgoing edges
	vector<uint> **edgeVecs = new vector<uint> *[grammar.labelSize];

	// check if an edge exist or not
	// only tried API unordered, never implemented by ourselves; key is generated by merging (COMBINE) two integers (end vertex and label)
	unordered_set<ull> *hashset = new unordered_set<ull>[num_nodes];
	// SF: hashset for incoming edges
	// unordered_set<ull> *inHashset = new unordered_set<ull>[num_nodes];

	queue<EdgeForReading2> activeQueue;
	queue<EdgeForReading2> futureQueue;

	cout << "#nodes " << num_nodes << endl;
	cout << "SF::#nodes " << nodes.size() << endl;
	cout << "#edges " << num_edges << endl;

	cout << "Start making sets and the hash ...\n";

	for (uint i = 0; i < grammar.labelSize; i++)
	{
		edgeVecs[i] = new vector<uint>[num_nodes];
		inEdgeVecs[i] = new vector<uint>[num_nodes];
	}

	for (uint i = 0; i < num_edges; i++)
	{
		edgeVecs[edges[i].label][edges[i].from].push_back(edges[i].to);
		inEdgeVecs[edges[i].label][edges[i].to].push_back(edges[i].from);

		hashset[edges[i].from].insert(COMBINE(edges[i].to, edges[i].label));
		// inHashset[edges[i].to].insert(COMBINE(edges[i].from, edges[i].label));

		activeQueue.push(edges[i]);
	}

	edges.clear();

	//  SF
	/*
	for(uint i=0; i<num_nodes; i++)
	{
		for(uint j=0; j<edgeVecs[i][NEW].size(); j++)
		{
			// i -----> edgeVecs[i][NEW][j]
			hashset[i].insert(COMBINE(edgeVecs[i][NEW][j].end, edgeVecs[i][NEW][j].label));

		}
	}
	*/

	// SF:: count the total no of initial unique edge
	uint initialEdgeCount = countEdge(hashset, num_nodes);

	cout << "Done!\n";

	// currently exclude the initialization time
	std::chrono::time_point<std::chrono::system_clock> start, finish;
	start = std::chrono::system_clock::now();

	std::chrono::time_point<std::chrono::system_clock> start_hash, finish_hash;
	std::chrono::time_point<std::chrono::system_clock> start_hash_true, finish_hash_true;

	atomic<int> newEdgeCounter(0);
	bool finished;
	int itr = 0;
	ull calcCnt = 0;
	ull calcCnt1 = 0;
	ull calcCnt2 = 0;
	ull calcCnt3_left = 0;
	ull calcCnt3_right = 0;

	double elapsed_seconds_comp = 0.0;
	double elapsed_seconds_transfer = 0.0;
	double elapsed_seconds_hash = 0.0;
	double elapsed_seconds_hash_true = 0.0;

	if (debug)
	{
		cout << "[DEBUG]: grammar1 size: " << grammar.grammar1.size() << endl;
	}
	// handle epsilon rules: add an edge to itself
	// grammar1 is for epsilon rules A --> e
	// grammar2 is for one symbol on RHS A --> B
	// grammar3 is for two symbols on RHS A --> BC
	for (uint l = 0; l < grammar.grammar1.size(); l++)
	{
		for (uint i = 0; i < num_nodes; i++)
		{
			calcCnt++;
			calcCnt1++;

			start_hash = std::chrono::system_clock::now();

			// check if the new edge based on an epsilon grammar rule exists or not. l: grammar ID, 0: LHS
			if (hashset[i].find(COMBINE(i, grammar.grammar1[l][0])) == hashset[i].end())
			{
				// start_hash_true = std::chrono::system_clock::now();
				//  insert into hashset
				hashset[i].insert(COMBINE(i, grammar.grammar1[l][0]));
				// inHashset[i].insert(COMBINE(i, grammar.grammar1[l][0]));
				//  insert into the graph
				edgeVecs[grammar.grammar1[l][0]][i].push_back(i);
				inEdgeVecs[grammar.grammar1[l][0]][i].push_back(i);

				activeQueue.push(EdgeForReading2(i, i, grammar.grammar1[l][0]));

				newEdgeCounter++;

				// finish_hash_true = std::chrono::system_clock::now();
				// std::chrono::duration<double> elapsed_secondsHash_true = finish_hash_true - start_hash_true;
				// elapsed_seconds_hash_true += elapsed_secondsHash_true.count();
			}

			finish_hash = std::chrono::system_clock::now();
			std::chrono::duration<double> elapsed_secondsHash = finish_hash - start_hash;
			elapsed_seconds_hash += elapsed_secondsHash.count();
		}
	}

	cout << "********************\n";

	do
	{
		itr++;

		std::chrono::time_point<std::chrono::system_clock> startC, finishC;
		startC = std::chrono::system_clock::now();

		while (!activeQueue.empty())
		{
			EdgeForReading2 currEdge = activeQueue.front();
			activeQueue.pop();

			// for each grammar rule like A --> B
			for (uint g = 0; g < grammar.grammar2index[currEdge.label].size(); g++)
			{
				calcCnt++;
				calcCnt2++;

				start_hash = std::chrono::system_clock::now();

				// if the edge to the neighbor is labeled with B
				if (hashset[currEdge.from].find(COMBINE(currEdge.to, grammar.grammar2index[currEdge.label][g])) == hashset[currEdge.from].end())
				{
					// start_hash_true = std::chrono::system_clock::now();
					// hashset[currEdge.from].insert(COMBINE(currEdge.to, grammar.grammar2index[currEdge.label][g]));
					//  inHashset[currEdge.to].insert(COMBINE(currEdge.from, grammar.grammar2index[currEdge.label][g]));

					// the new edge is added to FUTURE list, due to potential conflicts in parallel version
					edgeVecs[grammar.grammar2index[currEdge.label][g]][currEdge.from].push_back(currEdge.to);
					inEdgeVecs[grammar.grammar2index[currEdge.label][g]][currEdge.to].push_back(currEdge.from);
					futureQueue.push(EdgeForReading2(currEdge.from, currEdge.to, grammar.grammar2index[currEdge.label][g]));

					newEdgeCounter++;

					// finish_hash_true = std::chrono::system_clock::now();
					// std::chrono::duration<double> elapsed_secondsHash_true = finish_hash_true - start_hash_true;
					// elapsed_seconds_hash_true += elapsed_secondsHash_true.count();
				}

				finish_hash = std::chrono::system_clock::now();
				std::chrono::duration<double> elapsed_secondsHash = finish_hash - start_hash;
				elapsed_seconds_hash += elapsed_secondsHash.count();
			}

			// A = BC
			for (uint g = 0; g < grammar.grammar3indexLeft[currEdge.label].size(); g++)
			{
				uint B = currEdge.label;
				uint A = grammar.grammar3indexLeft[currEdge.label][g].second;
				uint C = grammar.grammar3indexLeft[currEdge.label][g].first;

				for (uint j = 0; j < edgeVecs[C][currEdge.to].size(); j++)
				{
					uint nbr;

					// A = BC, B = grammar.grammar3[g][1] = currEdge.label
					// NEW outgoing edges of currEdge.to
					nbr = edgeVecs[C][currEdge.to][j];
					// A = BC, C = grammar.grammar3[g][2]
					calcCnt++;
					calcCnt3_left++;

					start_hash = std::chrono::system_clock::now();

					if (hashset[currEdge.from].find(COMBINE(nbr, A)) == hashset[currEdge.from].end())
					{
						// start_hash_true = std::chrono::system_clock::now();
						hashset[currEdge.from].insert(COMBINE(nbr, A));
						// inHashset[nbr].insert(COMBINE(currEdge.from, A));
						edgeVecs[A][currEdge.from].push_back(nbr);
						inEdgeVecs[A][nbr].push_back(currEdge.from);
						futureQueue.push(EdgeForReading2(currEdge.from, nbr, A));
						newEdgeCounter++;

						// finish_hash_true = std::chrono::system_clock::now();
						// std::chrono::duration<double> elapsed_secondsHash_true = finish_hash_true - start_hash_true;
						// elapsed_seconds_hash_true += elapsed_secondsHash_true.count();
					}

					finish_hash = std::chrono::system_clock::now();
					std::chrono::duration<double> elapsed_secondsHash = finish_hash - start_hash;
					elapsed_seconds_hash += elapsed_secondsHash.count();
				}
			}

			// A = CB, B = grammar.grammar3[g][2] = currEdge.label
			for (uint g = 0; g < grammar.grammar3indexRight[currEdge.label].size(); g++)
			{
				uint B = currEdge.label;
				uint A = grammar.grammar3indexRight[currEdge.label][g].second;
				uint C = grammar.grammar3indexRight[currEdge.label][g].first;

				for (uint h = 0; h < inEdgeVecs[C][currEdge.from].size(); h++)
				{
					uint inNbr;
					inNbr = inEdgeVecs[C][currEdge.from][h];
					// A = CB, C = grammar.grammar3[g][1]
					calcCnt++;
					calcCnt3_right++;

					start_hash = std::chrono::system_clock::now();

					if (hashset[inNbr].find(COMBINE(currEdge.to, A)) == hashset[inNbr].end())
					{
						// start_hash_true = std::chrono::system_clock::now();
						hashset[inNbr].insert(COMBINE(currEdge.to, A));
						// inHashset[currEdge.to].insert(COMBINE(inNbr, A));
						edgeVecs[A][inNbr].push_back(currEdge.to);
						inEdgeVecs[A][currEdge.to].push_back(inNbr);
						futureQueue.push(EdgeForReading2(inNbr, currEdge.to, A));
						newEdgeCounter++;

						// finish_hash_true = std::chrono::system_clock::now();
						// std::chrono::duration<double> elapsed_secondsHash_true = finish_hash_true - start_hash_true;
						// elapsed_seconds_hash_true += elapsed_secondsHash_true.count();
					}

					finish_hash = std::chrono::system_clock::now();
					std::chrono::duration<double> elapsed_secondsHash = finish_hash - start_hash;
					elapsed_seconds_hash += elapsed_secondsHash.count();
				}
			}
		}

		cout << "Iteration number " << itr << endl;

		if (debug)
		{
			cout << "Number of new edges so far: " << newEdgeCounter << endl;
		}

		finishC = std::chrono::system_clock::now();
		std::chrono::duration<double> elapsed_secondsC = finishC - startC;
		std::time_t finish_timeC = std::chrono::system_clock::to_time_t(finishC);
		elapsed_seconds_comp += elapsed_secondsC.count();

		if (debug)
		{
			cout << "This Iteration Computation Time = " << elapsed_secondsC.count() << endl;
		}

		std::chrono::time_point<std::chrono::system_clock> startT, finishT;
		startT = std::chrono::system_clock::now();

		finished = true;

		if (!futureQueue.empty())
			finished = false;
		swap(activeQueue, futureQueue);

		finishT = std::chrono::system_clock::now();
		std::chrono::duration<double> elapsed_secondsT = finishT - startT;
		std::time_t finish_timeT = std::chrono::system_clock::to_time_t(finishT);
		elapsed_seconds_transfer += elapsed_secondsT.count();

		if (debug)
		{
			std::cout << "This Iteration Transformation Time = " << elapsed_secondsT.count() << std::endl;
		}

	} while (!finished);

	finish = std::chrono::system_clock::now();
	std::chrono::duration<double> elapsed_seconds = finish - start;
	std::time_t finish_time = std::chrono::system_clock::to_time_t(finish);

	uint totalNewEdgeCount = countEdge(hashset, num_nodes) - initialEdgeCount;

	cout << "**************************" << endl;
	std::cout << "# Total time = " << elapsed_seconds.count() << std::endl;
	std::cout << "# Total computation time = " << elapsed_seconds_comp << std::endl;
	std::cout << "# Total data transfer time = " << elapsed_seconds_transfer << std::endl;

	cout << "SF:: # Number of new edges: " << totalNewEdgeCount << endl;
	cout << "AM:: # Number of new edges: " << newEdgeCounter << endl;

	cout << "# Iterations: " << itr << endl;
	cout << "# Total Calculations: " << calcCnt << endl;

	cout << "Total hash time: " << elapsed_seconds_hash << endl;
	cout << "Total hash true time: " << elapsed_seconds_hash_true << endl;
	cout << "Total hash false time: " << elapsed_seconds_hash - elapsed_seconds_hash_true << endl;
}
